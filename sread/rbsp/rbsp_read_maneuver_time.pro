;+
; Return the times of maneuver within the given time range.
;-

function rbsp_read_maneuver_time, time, probe=probe, $
    local_files=files, file_times=file_times, version=version, $
    local_root=local_root, remote_root=remote_root

    compile_opt idl2
    on_error, 0
    errmsg = ''
    retval = !null
    
    ntime =  n_elements(time)
    case ntime of
        1: timespan, time, 1, /day
        2: timespan, time[0], time[1]-time[0], /seconds
        else: return, retval
    endcase
    
    info = rbsp_load_maneuver_times(probe)
    if n_elements(info) eq 0 then return, retval
    return, [[info.estart],[info.eend]]


;;---Check inputs.
;    sync_threshold = 0
;    if n_elements(probe) eq 0 then probe = 'x'
;    if n_elements(local_root) eq 0 then local_root = join_path([default_local_root(),'data','rbsp'])
;    if n_elements(remote_root) eq 0 then remote_root = 'http://themis.ssl.berkeley.edu/data/rbsp'
;
;    rbspx = 'rbsp'+probe
;    paths = ['MOC_data_products',strupcase(rbspx),'maneuver_sequence']
;    data_file = join_path([local_root,paths,rbspx+'_maneuver_times.cdf'])
;    the_var = rbspx+'_maneuver_times'
;    if file_test(data_file) eq 0 then begin
;        ; Download the index file.
;        remote_index_file = join_path([remote_root,paths])+'/'
;        local_index_file = join_path([local_root,paths,default_index_file()])
;        download_file, local_index_file, remote_index_file
;
;        ; Find all related mseq files.
;        lines = read_all_lines(local_index_file)
;        file_pattern = '"'+strupcase(probe)+'_[0-9]{4}_[0-9]{3}_[0-9]{2}.mseq"'
;        pos = stregex(lines, file_pattern)
;        index = where(pos ne -1, count)
;        if count eq 0 then return, retval
;        files = lines[index]
;        nfile = n_elements(files)
;        length = 18
;        for ii=0,nfile-1 do files[ii] = strmid(files[ii],stregex(files[ii],file_pattern)+1, length)
;
;        ; Sync the mseq files with server.
;        foreach file, files do begin
;            local_file = join_path([local_root,paths,file])
;            remote_file = join_path([remote_root,paths,file])
;            download_flag = 0
;            finfo = file_info(local_file)
;            rinfo = get_remote_info(remote_file)
;            if finfo.size ne rinfo.size then download_flag = 1
;            if download_flag then download_file, local_file, remote_file, errmsg=errmsg
;            if finfo.mtime ne rinfo.mtime then ftouch, local_file, mtime=mtime
;        endforeach
;
;        ; Read maneuver times.
;        maneuver_times = dblarr(nfile)
;        the_line_id = 2
;        foreach file, files, ii do begin
;            local_file = join_path([local_root,paths,file])
;            lines = read_all_lines(local_file)
;            the_line = lines[the_line_id]
;            the_time = (strsplit(the_line,' ',/extract))[1]
;            maneuver_times[ii] = time_double(the_time, tformat='YYYY:DOY:hh:mm:ss')
;        endforeach
;
;        ; Save to file.
;        odir = fgetpath(data_file)
;        if file_test(odir,/directory) eq 0 then file_mkdir, odir
;        offn = data_file
;        if file_test(offn) eq 1 then file_delete, offn  ; overwrite old files.
;
;        ginfo = {$
;            title: 'RBSP position and boom direction from SPICE kernel',$
;            text: 'Generated by Sheng Tian at the University of Minnesota'}
;        scdfwrite, offn, gattribute=ginfo
;
;        the_var = rbspx+'_maneuver_times'
;        ainfo = {$
;            fieldnam: 'UT time', $
;            units: 'sec', $
;            var_type: 'support_data'}
;        scdfwrite, offn, the_var, value=maneuver_times, attribute=ainfo, cdftype='CDF_DOUBLE'
;    endif
;
;    maneuver_times = cdf_read_var(the_var, filename=data_file)
;    if n_elements(time) eq 0 then begin
;        return, maneuver_times
;    endif else if n_elements(time) eq 1 then begin
;        index = where(abs(maneuver_times-time) le time_error, count)
;        if count eq 0 then return, retval
;        return, maneuver_times[index]
;    endif else if n_elements(time) eq 2 then begin
;        index = lazy_where(maneuver_times, '[]', time, count=count)
;        if count eq 0 then return, retval
;        return, maneuver_times[index]
;    endif

end

time_range = time_double(['2013','2014'])
probe = 'b'
times = rbsp_read_maneuver_time(time_range, probe=probe)
end